@using Elwin.GoGroceries.Client.Helpers;
@using Elwin.GoGroceries.Contracts;
@using Elwin.GoGroceries.Client.Components;
@inject HttpClient Http
@inject NavigationManager Navigation
@page "/grocerylist/{id:guid}"

<MudPaper Width="100%">
    @if(categories is not null & groceryList?.Products is not null)
    {
        <MudExpansionPanels MultiExpansion="true">
            @foreach(var category in categories)
            {
                <MudExpansionPanel Text="@category.Name">
                    <ul>
                        @foreach(var item in groceryList.Products.Where(i => i.CategoryId == category.Id & !i.IsCheckedOff))
                        {
                            <ListProductComponent Product="item" OnDelete="Delete" OnClickListItem="ClickListItem"></ListProductComponent>
                        }
                        <li @onclick="() => AddNew()">
                            <MudIcon Icon="@Icons.Material.Filled.Add"></MudIcon> Add item
                        </li>
                    </ul>
                </MudExpansionPanel >
            }
            <MudExpansionPanel Text="Unassigned products">
                    <ul>
                        @foreach(var item in groceryList.Products.Where(i => i.CategoryId is null && !i.IsCheckedOff))
                        {
                        <ListProductComponent Product="item" OnDelete="Delete" OnClickListItem="ClickListItem"></ListProductComponent>
                        }
                        <li @onclick="() => AddNew()">
                            <MudIcon Icon="@Icons.Material.Filled.Add"></MudIcon> Add item
                        </li>
                    </ul>
            </MudExpansionPanel >
            <MudExpansionPanel Text="Checked off products">
                    <ul style="text-decoration: line-through">
                        @foreach(var item in groceryList.Products.Where(i => i.IsCheckedOff))
                        {
                        <ListProductComponent Product="item" OnDelete="Delete" OnClickListItem="ClickListItem"></ListProductComponent>
                        }
                    </ul>
            </MudExpansionPanel>
        </MudExpansionPanels>
    }  
</MudPaper>

@code {
    [Parameter]
    public Guid Id { get; set; }

    private GroceryListDto? groceryList { get; set; }
    private IEnumerable<CategoryDto>? categories { get; set; }

    protected override async Task OnInitializedAsync()
    {
        var categoriesRes = await Http.GetAsync($"Categories");
        categories = await HttpResultHelper.Process(categoriesRes, () => categoriesRes.Content.ReadFromJsonAsync<IEnumerable<CategoryDto>>());

        var groceryListRes = await Http.GetAsync($"GroceryLists/{Id}");
        groceryList = await HttpResultHelper.Process(groceryListRes, () => groceryListRes.Content.ReadFromJsonAsync<GroceryListDto>());
    }

    protected void AddNew()
    {
        Navigation.NavigateTo($"/groceryList/{Id}/add");
    }

    protected async Task Delete(Guid productId)
    {
        var res = await Http.DeleteAsync($"GroceryLists/{Id}/{productId}");

        if (res.IsSuccessStatusCode)
        {
            groceryList?.Products?.Remove(groceryList.Products.Single(i => i.Id == productId));
            StateHasChanged();
        }
    }

    protected async Task ClickListItem(Guid productId)
    {
        var product = groceryList?.Products?.Single(i => i.Id == productId);
        var res = await Http.PutAsync($"GroceryLists/{Id}", JsonSerializerHelper.Process(product));

        if (res.IsSuccessStatusCode)
        {
            // Something to think about: is it more correct to find and update the original item, or update the item entirely?
            // To update the item entirely without losing index, we must switch from using an ICollection to a List
            var resProduct = await HttpResultHelper.Process(res, () => res.Content.ReadFromJsonAsync<ProductDto>());
            var originalProduct = groceryList?.Products?.Single(i => i.Id == resProduct?.Id);
            originalProduct.IsCheckedOff = resProduct.IsCheckedOff;
            StateHasChanged();
        }
    }
}
